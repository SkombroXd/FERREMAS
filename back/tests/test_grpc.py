#!/usr/bin/env python3
"""
Script de pruebas para el servicio gRPC de productos
Incluye pruebas de conexi√≥n, validaci√≥n, timeout, carga, cancelaci√≥n y autenticaci√≥n
"""

import sys
import os
import uuid
# Agregar el directorio padre al path para importar los m√≥dulos de protobuf
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import grpc
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from producto_pb2 import CrearProductoRequest, ListarProductosRequest
from producto_pb2_grpc import ProductoServiceStub

# Configuraci√≥n del cliente
HOST = 'localhost'
PORT = 50051
ADDRESS = f'{HOST}:{PORT}'

def generar_codigo():
    return str(uuid.uuid4())[:8]

def test_1_conexion_exitosa():
    """üîπ1. Prueba de conexi√≥n exitosa"""
    print("\nüîπ1. Probando conexi√≥n exitosa...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        grpc.channel_ready_future(channel).result(timeout=5)
        print("‚úÖ Conexi√≥n exitosa")
        channel.close()
        return True
    except grpc.FutureTimeoutError:
        print("‚ùå No se pudo conectar al servidor gRPC")
        return False
    except Exception as e:
        print(f"‚ùå Error de conexi√≥n: {e}")
        return False

def test_2_llamada_valida():
    """üîπ2. Llamada v√°lida"""
    print("\nüîπ2. Probando llamada v√°lida...")
    with grpc.insecure_channel(ADDRESS) as channel:
        stub = ProductoServiceStub(channel)
        cod = generar_codigo()
        nombre_unico = f"Martillo-{generar_codigo()}"
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto=f"FER-{cod}",
            nombre_p=nombre_unico,
            precio_p=9990
        ))
        if not response.exito:
            print(f"‚ùå Fall√≥: {response.mensaje}")
            return False
        print(f"‚úÖ Producto creado: Producto {nombre_unico} creado correctamente")
        channel.close()
        return True

def test_3_datos_invalidos():
    """üîπ3. Llamada con datos inv√°lidos"""
    print("\nüîπ3. Probando datos inv√°lidos...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        cod = generar_codigo()
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto="",  # Inv√°lido
            nombre_p="",
            precio_p=-1
        ))
        if response.exito:
            print("‚ùå Error: El servidor acept√≥ datos inv√°lidos")
            return False
        else:
            print("‚úÖ El servidor rechaz√≥ datos inv√°lidos")
            return True
    except Exception as e:
        print(f"‚úÖ Excepci√≥n esperada por datos inv√°lidos: {e}")
        return True

def test_4_timeout():
    """üîπ4. Prueba de timeout"""
    print("\nüîπ4. Probando timeout...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        cod = generar_codigo()
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto=f"FER-{cod}",
            nombre_p="Producto Lento",
            precio_p=1000
        ), timeout=0.001)  # Timeout muy corto
        if not response.exito:
            print(f"‚ùå Fall√≥: {response.mensaje}")
            return False
        print("‚ö†Ô∏è  No se detect√≥ timeout")
        channel.close()
        return True
    except grpc.RpcError as e:
        if e.code() == grpc.StatusCode.DEADLINE_EXCEEDED:
            print("‚è± Timeout detectado correctamente")
            channel.close()
            return True
        else:
            print(f"‚ùå Error diferente al timeout: {e.code()}")
            channel.close()
            return False
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_5_cancelacion():
    """üîπ5. Prueba de cancelaci√≥n de llamada"""
    print("\nüîπ5. Probando cancelaci√≥n...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Crear llamada as√≠ncrona
        cod = generar_codigo()
        call = stub.CrearProducto.future(CrearProductoRequest(
            cod_producto=f"CANCEL-{cod}",
            nombre_p="Cancelar",
            precio_p=1000
        ))
        
        # Cancelar inmediatamente
        call.cancel()
        
        # Verificar si fue cancelada
        if call.cancelled():
            print("üõë Llamada cancelada correctamente")
            channel.close()
            return True
        else:
            print("‚ö†Ô∏è  La llamada no fue cancelada")
            channel.close()
            return False
            
    except Exception as e:
        print(f"‚ùå Error en cancelaci√≥n: {e}")
        channel.close()
        return False

def test_6_autenticacion():
    """üîπ6. Prueba de autenticaci√≥n (metadata)"""
    print("\nüîπ6. Probando autenticaci√≥n...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        cod = generar_codigo()
        nombre_unico = f"Protegido-{generar_codigo()}"
        response = stub.CrearProducto(
            CrearProductoRequest(
                cod_producto=f"AUTH-{cod}",
                nombre_p=nombre_unico,
                precio_p=1000
            ),
            metadata=[('authorization', 'Bearer TOKEN_INVALIDO')]
        )
        
        if not response.exito:
            print(f"‚ùå Fall√≥ autenticaci√≥n: {response.mensaje}")
            return False
        print("‚ö†Ô∏è  No se implement√≥ autenticaci√≥n en el servidor")
        channel.close()
        return True  # No es un error si no est√° implementado
        
    except grpc.RpcError as e:
        if e.code() == grpc.StatusCode.UNAUTHENTICATED:
            print("üö´ Acceso denegado correctamente")
            channel.close()
            return True
        else:
            print(f"‚ùå Error diferente: {e.code()}")
            channel.close()
            return False
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_7_error_servidor():
    """üîπ7. Manejo de errores del servidor"""
    print("\nüîπ7. Probando error del servidor...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Intentar crear producto con nombre que podr√≠a causar error
        cod = generar_codigo()
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto=f"ERR-{cod}",
            nombre_p="ERROR",  # Nombre que podr√≠a activar excepci√≥n en el servidor
            precio_p=0
        ))
        
        if not response.exito:
            print(f"üí• Error del servidor detectado: {response.mensaje}")
            return True
        else:
            print("‚ö†Ô∏è  No se detect√≥ error del servidor")
            return False
        
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_9_prueba_carga():
    """üîπ9. Prueba de carga b√°sica"""
    print("\nüîπ9. Probando carga b√°sica...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        exitosos = 0
        total = 10
        for _ in range(total):
            cod = generar_codigo()
            nombre = f"Carga-{generar_codigo()}"
            response = stub.CrearProducto(CrearProductoRequest(
                cod_producto=f"FER-{cod}",
                nombre_p=nombre,
                precio_p=1000
            ))
            if response.exito:
                exitosos += 1
        
        print(f"‚úÖ Prueba de carga completada: {exitosos}/{total} exitosos")
        channel.close()
        return exitosos == total
        
    except Exception as e:
        print(f"‚ùå Error en prueba de carga: {e}")
        channel.close()
        return False

def test_10_manejo_errores_servidor():
    """üîπ10. Manejo de errores del servidor"""
    print("\nüîπ10. Probando manejo de errores internos del servidor...")
    with grpc.insecure_channel(ADDRESS) as channel:
        stub = ProductoServiceStub(channel)
        # Forzar un error interno enviando un nombre especial
        try:
            response = stub.CrearProducto(CrearProductoRequest(
                cod_producto="FORCE-ERR",
                nombre_p="ERROR",  # El backend lanza excepci√≥n con este nombre
                precio_p=1000
            ))
            if not response.exito and "Error interno" in response.mensaje:
                print(f"‚úÖ Error interno detectado y mensaje recibido: {response.mensaje}")
                return True
            else:
                print(f"‚ùå No se detect√≥ el error interno esperado. Mensaje: {response.mensaje}")
                return False
        except grpc.RpcError as e:
            print(f"‚úÖ Excepci√≥n gRPC capturada: {e.code()} - {e.details()}")
            return True

def ejecutar_todas_las_pruebas():
    """Ejecuta todas las pruebas y muestra un resumen"""
    print("üöÄ Iniciando pruebas del servicio gRPC de productos")
    print("=" * 60)
    
    pruebas = [
        ("Conexi√≥n exitosa", test_1_conexion_exitosa),
        ("Llamada v√°lida", test_2_llamada_valida),
        ("Datos inv√°lidos", test_3_datos_invalidos),
        ("Timeout", test_4_timeout),
        ("Cancelaci√≥n", test_5_cancelacion),
        ("Autenticaci√≥n", test_6_autenticacion),
        ("Error del servidor", test_7_error_servidor),
        ("Prueba de carga", test_9_prueba_carga),
        ("Manejo de errores del servidor", test_10_manejo_errores_servidor)
    ]
    
    resultados = []
    
    for nombre, prueba in pruebas:
        try:
            resultado = prueba()
            resultados.append((nombre, resultado))
        except Exception as e:
            print(f"‚ùå Error ejecutando {nombre}: {e}")
            resultados.append((nombre, False))
    
    # Resumen final
    print("\n" + "=" * 60)
    print("üìä RESUMEN DE PRUEBAS")
    print("=" * 60)
    
    exitosos = 0
    for nombre, resultado in resultados:
        estado = "‚úÖ PAS√ì" if resultado else "‚ùå FALL√ì"
        print(f"{estado} - {nombre}")
        if resultado:
            exitosos += 1
    
    print(f"\nüéØ Resultado final: {exitosos}/{len(resultados)} pruebas exitosas")
    
    if exitosos == len(resultados):
        print("üéâ ¬°Todas las pruebas pasaron!")
    elif exitosos >= len(resultados) * 0.8:
        print("üëç La mayor√≠a de las pruebas pasaron")
    else:
        print("‚ö†Ô∏è  Muchas pruebas fallaron, revisar el servidor")

if __name__ == "__main__":
    ejecutar_todas_las_pruebas() 