#!/usr/bin/env python3
"""
Script de pruebas para el servicio gRPC de productos
Incluye pruebas de conexi√≥n, validaci√≥n, timeout, carga, cancelaci√≥n y autenticaci√≥n
"""

import sys
import os
# Agregar el directorio padre al path para importar los m√≥dulos de protobuf
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

import grpc
import time
import threading
from concurrent.futures import ThreadPoolExecutor
from producto_pb2 import CrearProductoRequest, ListarProductosRequest
from producto_pb2_grpc import ProductoServiceStub

# Configuraci√≥n del cliente
HOST = 'localhost'
PORT = 50051
ADDRESS = f'{HOST}:{PORT}'

def test_1_conexion_exitosa():
    """üîπ1. Prueba de conexi√≥n exitosa"""
    print("\nüîπ1. Probando conexi√≥n exitosa...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        grpc.channel_ready_future(channel).result(timeout=5)
        print("‚úÖ Conexi√≥n exitosa")
        channel.close()
        return True
    except grpc.FutureTimeoutError:
        print("‚ùå No se pudo conectar al servidor gRPC")
        return False
    except Exception as e:
        print(f"‚ùå Error de conexi√≥n: {e}")
        return False

def test_2_llamada_valida():
    """üîπ2. Llamada v√°lida"""
    print("\nüîπ2. Probando llamada v√°lida...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto="FER-001",
            nombre_p="Martillo",
            precio_p=9990,
            unidades_p=20
        ))
        print("‚úÖ Producto creado:", response.mensaje)
        channel.close()
        return True
    except Exception as e:
        print(f"‚ùå Error en llamada v√°lida: {e}")
        return False

def test_3_datos_invalidos():
    """üîπ3. Llamada con datos inv√°lidos"""
    print("\nüîπ3. Probando datos inv√°lidos...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        stub.CrearProducto(CrearProductoRequest(
            cod_producto="",  # C√≥digo vac√≠o
            nombre_p="",      # Nombre vac√≠o
            precio_p=-10,     # Precio inv√°lido
            unidades_p=-1     # Stock negativo
        ))
        print("‚ö†Ô∏è  No se detect√≥ error con datos inv√°lidos")
        channel.close()
        return False
    except grpc.RpcError as e:
        print(f"‚ùå Error esperado: {e.code()} - {e.details()}")
        channel.close()
        return True
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_4_timeout():
    """üîπ4. Prueba de timeout"""
    print("\nüîπ4. Probando timeout...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        stub.CrearProducto(CrearProductoRequest(
            cod_producto="FER-002",
            nombre_p="Producto Lento",
            precio_p=1000,
            unidades_p=5
        ), timeout=0.001)  # Timeout muy corto
        print("‚ö†Ô∏è  No se detect√≥ timeout")
        channel.close()
        return False
    except grpc.RpcError as e:
        if e.code() == grpc.StatusCode.DEADLINE_EXCEEDED:
            print("‚è± Timeout detectado correctamente")
            channel.close()
            return True
        else:
            print(f"‚ùå Error diferente al timeout: {e.code()}")
            channel.close()
            return False
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_5_cancelacion():
    """üîπ5. Prueba de cancelaci√≥n de llamada"""
    print("\nüîπ5. Probando cancelaci√≥n...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Crear llamada as√≠ncrona
        call = stub.CrearProducto.future(CrearProductoRequest(
            cod_producto="CANCEL",
            nombre_p="Cancelar",
            precio_p=1000,
            unidades_p=1
        ))
        
        # Cancelar inmediatamente
        call.cancel()
        
        # Verificar si fue cancelada
        if call.cancelled():
            print("üõë Llamada cancelada correctamente")
            channel.close()
            return True
        else:
            print("‚ö†Ô∏è  La llamada no fue cancelada")
            channel.close()
            return False
            
    except Exception as e:
        print(f"‚ùå Error en cancelaci√≥n: {e}")
        channel.close()
        return False

def test_6_autenticacion():
    """üîπ6. Prueba de autenticaci√≥n (metadata)"""
    print("\nüîπ6. Probando autenticaci√≥n...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Metadata con token inv√°lido
        metadata = [('authorization', 'Bearer TOKEN_INVALIDO')]
        
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto="AUTH",
            nombre_p="Protegido",
            precio_p=1000,
            unidades_p=1
        ), metadata=metadata)
        
        print("‚ö†Ô∏è  No se implement√≥ autenticaci√≥n en el servidor")
        channel.close()
        return True  # No es un error si no est√° implementado
        
    except grpc.RpcError as e:
        if e.code() == grpc.StatusCode.UNAUTHENTICATED:
            print("üö´ Acceso denegado correctamente")
            channel.close()
            return True
        else:
            print(f"‚ùå Error diferente: {e.code()}")
            channel.close()
            return False
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_7_error_servidor():
    """üîπ7. Manejo de errores del servidor"""
    print("\nüîπ7. Probando error del servidor...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Intentar crear producto con nombre que podr√≠a causar error
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto="ERR",
            nombre_p="ERROR",  # Nombre que podr√≠a activar excepci√≥n en el servidor
            precio_p=0,
            unidades_p=0
        ))
        
        print("‚ö†Ô∏è  No se detect√≥ error del servidor")
        channel.close()
        return True
        
    except grpc.RpcError as e:
        print(f"üí• Error del servidor detectado: {e.code()} - {e.details()}")
        channel.close()
        return True
    except Exception as e:
        print(f"‚ùå Error inesperado: {e}")
        channel.close()
        return False

def test_8_listar_productos():
    """üîπ8. Prueba de listar productos"""
    print("\nüîπ8. Probando listar productos...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        response = stub.ListarProductos(ListarProductosRequest())
        print(f"‚úÖ Productos listados: {len(response.productos)} productos encontrados")
        
        # Mostrar algunos productos
        for i, producto in enumerate(response.productos[:3]):  # Solo los primeros 3
            print(f"   {i+1}. {producto.cod_producto} - {producto.nombre_p} - ${producto.precio_p}")
        
        channel.close()
        return True
        
    except Exception as e:
        print(f"‚ùå Error al listar productos: {e}")
        channel.close()
        return False

def test_9_prueba_carga():
    """üîπ9. Prueba de carga b√°sica"""
    print("\nüîπ9. Probando carga b√°sica...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        def crear_producto_concurrente(i):
            try:
                response = stub.CrearProducto(CrearProductoRequest(
                    cod_producto=f"FER-{i:03d}",
                    nombre_p=f"Producto Carga {i}",
                    precio_p=1000 + i,
                    unidades_p=i
                ))
                return response.exito
            except:
                return False
        
        # Crear 10 productos concurrentemente
        start_time = time.time()
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(crear_producto_concurrente, i) for i in range(1, 11)]
            results = [future.result() for future in futures]
        
        end_time = time.time()
        exitosos = sum(results)
        
        print(f"‚úÖ Prueba de carga completada: {exitosos}/10 exitosos en {end_time - start_time:.2f}s")
        channel.close()
        return exitosos >= 8  # Al menos 8 deben ser exitosos
        
    except Exception as e:
        print(f"‚ùå Error en prueba de carga: {e}")
        channel.close()
        return False

def test_10_validacion_campos():
    """üîπ10. Prueba de validaci√≥n de campos espec√≠ficos"""
    print("\nüîπ10. Probando validaci√≥n de campos...")
    try:
        channel = grpc.insecure_channel(ADDRESS)
        stub = ProductoServiceStub(channel)
        
        # Probar con precio muy alto
        response = stub.CrearProducto(CrearProductoRequest(
            cod_producto="PRICE-TEST",
            nombre_p="Producto Caro",
            precio_p=999999999.99,
            unidades_p=1
        ))
        
        if response.exito:
            print("‚úÖ Producto con precio alto creado")
        else:
            print(f"‚ùå Error con precio alto: {response.mensaje}")
        
        # Probar con nombre muy largo
        nombre_largo = "A" * 1000  # Nombre de 1000 caracteres
        response2 = stub.CrearProducto(CrearProductoRequest(
            cod_producto="LONG-NAME",
            nombre_p=nombre_largo,
            precio_p=100,
            unidades_p=1
        ))
        
        if response2.exito:
            print("‚úÖ Producto con nombre largo creado")
        else:
            print(f"‚ùå Error con nombre largo: {response2.mensaje}")
        
        channel.close()
        return True
        
    except Exception as e:
        print(f"‚ùå Error en validaci√≥n: {e}")
        channel.close()
        return False

def ejecutar_todas_las_pruebas():
    """Ejecuta todas las pruebas y muestra un resumen"""
    print("üöÄ Iniciando pruebas del servicio gRPC de productos")
    print("=" * 60)
    
    pruebas = [
        ("Conexi√≥n exitosa", test_1_conexion_exitosa),
        ("Llamada v√°lida", test_2_llamada_valida),
        ("Datos inv√°lidos", test_3_datos_invalidos),
        ("Timeout", test_4_timeout),
        ("Cancelaci√≥n", test_5_cancelacion),
        ("Autenticaci√≥n", test_6_autenticacion),
        ("Error del servidor", test_7_error_servidor),
        ("Listar productos", test_8_listar_productos),
        ("Prueba de carga", test_9_prueba_carga),
        ("Validaci√≥n de campos", test_10_validacion_campos)
    ]
    
    resultados = []
    
    for nombre, prueba in pruebas:
        try:
            resultado = prueba()
            resultados.append((nombre, resultado))
        except Exception as e:
            print(f"‚ùå Error ejecutando {nombre}: {e}")
            resultados.append((nombre, False))
    
    # Resumen final
    print("\n" + "=" * 60)
    print("üìä RESUMEN DE PRUEBAS")
    print("=" * 60)
    
    exitosos = 0
    for nombre, resultado in resultados:
        estado = "‚úÖ PAS√ì" if resultado else "‚ùå FALL√ì"
        print(f"{estado} - {nombre}")
        if resultado:
            exitosos += 1
    
    print(f"\nüéØ Resultado final: {exitosos}/{len(resultados)} pruebas exitosas")
    
    if exitosos == len(resultados):
        print("üéâ ¬°Todas las pruebas pasaron!")
    elif exitosos >= len(resultados) * 0.8:
        print("üëç La mayor√≠a de las pruebas pasaron")
    else:
        print("‚ö†Ô∏è  Muchas pruebas fallaron, revisar el servidor")

if __name__ == "__main__":
    ejecutar_todas_las_pruebas() 